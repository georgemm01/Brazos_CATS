// Generated at Tue Jan  6 18:12:18 2015. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gccxml/20110825-cms3/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gccxml/20110825-cms3/bin/gccxml_cc1plus"
  GCCXML_CPP="/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gccxml/20110825-cms3/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='2' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.7.2"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='7' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gccxml/20110825-cms3/share/gccxml-0.9/GCC/4.7" -isystem"/home/georgemm01/local/include" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/backward" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include-fixed" -isystem"/usr/local/include" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gccxml/20110825-cms3/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.7.2
Copyright (C) 2012 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/JetMETAnalysis/JetUtilities/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::Type type_62 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_57 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_658 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_2731 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_2766 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_9 = ::Reflex::TypeBuilder(Reflex::Literal("JRAEvent"));
  ::Reflex::Type type_2815 = ::Reflex::TypeBuilder(Reflex::Literal("long long"));
  ::Reflex::Type type_222 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_1928 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_3410 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_2260 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_2259 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<float>"));
  ::Reflex::Type type_1348 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<JRAEvent>"));
  ::Reflex::Type type_3359 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<JRAEvent>"));
  ::Reflex::Type type_2029 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<JRAEvent>"));
  ::Reflex::Type type_2465 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<JRAEvent>"));
  ::Reflex::Type type_2240 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2241 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_3362 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<JRAEvent>"));
  ::Reflex::Type type_3358 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<JRAEvent> >"));
  ::Reflex::Type type_2028 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<JRAEvent> >"));
  ::Reflex::Type type_3361 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<JRAEvent> >"));
  ::Reflex::Type type_3866 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<JRAEvent> >"));
  ::Reflex::Type type_1806 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<JRAEvent,std::allocator<JRAEvent> >"));
  ::Reflex::Type type_3324 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_3877 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<JRAEvent*,std::vector<JRAEvent> >"));
  ::Reflex::Type type_3879 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const JRAEvent*,std::vector<JRAEvent> >"));
  ::Reflex::Type type_2572 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<JRAEvent*,std::vector<JRAEvent> > >"));
  ::Reflex::Type type_2571 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const JRAEvent*,std::vector<JRAEvent> > >"));
  ::Reflex::Type type_3873 = ::Reflex::ReferenceBuilder(type_9);
  ::Reflex::Type type_9c = ::Reflex::ConstBuilder(type_9);
  ::Reflex::Type type_3875 = ::Reflex::ReferenceBuilder(type_9c);
  ::Reflex::Type type_3869 = ::Reflex::PointerBuilder(type_9);
  ::Reflex::Type type_3871 = ::Reflex::PointerBuilder(type_9c);
  ::Reflex::Type type_2451 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_222);
  ::Reflex::Type type_2348 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_57);
  ::Reflex::Type type_2465c = ::Reflex::ConstBuilder(type_2465);
  ::Reflex::Type type_14581 = ::Reflex::ReferenceBuilder(type_2465c);
  ::Reflex::Type type_1348c = ::Reflex::ConstBuilder(type_1348);
  ::Reflex::Type type_14582 = ::Reflex::ReferenceBuilder(type_1348c);
  ::Reflex::Type type_14583 = ::Reflex::ReferenceBuilder(type_1348);
  ::Reflex::Type type_21970 = ::Reflex::PointerBuilder(type_1348c);
  ::Reflex::Type type_1928c = ::Reflex::ConstBuilder(type_1928);
  ::Reflex::Type type_3342 = ::Reflex::ReferenceBuilder(type_1928c);
  ::Reflex::Type type_21971 = ::Reflex::PointerBuilder(type_1348);
  ::Reflex::Type type_3361c = ::Reflex::ConstBuilder(type_3361);
  ::Reflex::Type type_21972 = ::Reflex::PointerBuilder(type_3361c);
  ::Reflex::Type type_3410c = ::Reflex::ConstBuilder(type_3410);
  ::Reflex::Type type_13778 = ::Reflex::ReferenceBuilder(type_3410c);
  ::Reflex::Type type_17840 = ::Reflex::ReferenceBuilder(type_2240);
  ::Reflex::Type type_21914 = ::Reflex::ReferenceBuilder(type_3324);
  ::Reflex::Type type_2731c = ::Reflex::ConstBuilder(type_2731);
  ::Reflex::Type type_2794 = ::Reflex::PointerBuilder(type_2731c);
  ::Reflex::Type type_5051 = ::Reflex::ReferenceBuilder(type_2794);
  ::Reflex::Type type_2241c = ::Reflex::ConstBuilder(type_2241);
  ::Reflex::Type type_17841 = ::Reflex::ReferenceBuilder(type_2241c);
  ::Reflex::Type type_3362c = ::Reflex::ConstBuilder(type_3362);
  ::Reflex::Type type_21975 = ::Reflex::PointerBuilder(type_3362c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __JRAEvent
#undef __JRAEvent
#endif
struct __JRAEvent {
  public:
  __JRAEvent();
  int nref;
  float rho;
  float rho50;
  float rho_hlt;
  float pthat;
  float weight;
  long long npv;
  long long run;
  long long lumi;
  long long evt;
  ::std::vector<int> npus;
  ::std::vector<int> bxns;
  ::std::vector<int> ntrks_lowpt;
  ::std::vector<int> ntrks_highpt;
  ::std::vector<int> nrefrank;
  ::std::vector<int> refpdgid;
  ::std::vector<int> refpdgid_algorithmicDef;
  ::std::vector<int> refpdgid_physicsDef;
  ::std::vector<float> tnpus;
  ::std::vector<float> zpositions;
  ::std::vector<float> sumpt_lowpt;
  ::std::vector<float> sumpt_highpt;
  ::std::vector<float> refe;
  ::std::vector<float> refpt;
  ::std::vector<float> refeta;
  ::std::vector<float> refphi;
  ::std::vector<float> refy;
  ::std::vector<float> refdrjt;
  ::std::vector<float> refdphijt;
  ::std::vector<float> refarea;
  ::std::vector<float> jte;
  ::std::vector<float> jtpt;
  ::std::vector<float> jteta;
  ::std::vector<float> jtphi;
  ::std::vector<float> jty;
  ::std::vector<float> jtjec;
  ::std::vector<float> jtarea;
  ::std::vector<float> jtemf;
  ::std::vector<float> jtchf;
  ::std::vector<float> jtnhf;
  ::std::vector<float> jtnef;
  ::std::vector<float> jtcef;
  ::std::vector<float> jtmuf;
  ::std::vector<float> jthfhf;
  ::std::vector<float> jthfef;
  ::std::vector<float> refdzvtx;
};
#ifdef __std__vector_JRAEvent_
#undef __std__vector_JRAEvent_
#endif
class __std__vector_JRAEvent_ : protected ::std::_Vector_base<JRAEvent,std::allocator<JRAEvent> > {
  public:
  __std__vector_JRAEvent_();
};
#ifdef __edm__Wrapper_std__vector_JRAEvent_s_
#undef __edm__Wrapper_std__vector_JRAEvent_s_
#endif
class __edm__Wrapper_std__vector_JRAEvent_s_ {
  public:
  __edm__Wrapper_std__vector_JRAEvent_s_();
  bool present;
  ::std::vector<JRAEvent> obj;
};
#ifdef __edm__Wrapper_JRAEvent_
#undef __edm__Wrapper_JRAEvent_
#endif
class __edm__Wrapper_JRAEvent_ {
  public:
  __edm__Wrapper_JRAEvent_();
  bool present;
  ::JRAEvent obj;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class JRAEvent -------------------------------
static void destructor_2726(void*, void * o, const std::vector<void*>&, void *) {
(((::JRAEvent*)o)->::JRAEvent::~JRAEvent)();
}
static  void operator_2727( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::JRAEvent*)o)->operator=)(*(const ::JRAEvent*)arg[0]);
  else   (((::JRAEvent*)o)->operator=)(*(const ::JRAEvent*)arg[0]);
}

static void constructor_2728( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::JRAEvent(*(const ::JRAEvent*)arg[0]);
  else ::new(mem) ::JRAEvent(*(const ::JRAEvent*)arg[0]);
}

static void constructor_2729( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::JRAEvent(*(int*)arg[0],
      *(float*)arg[1],
      *(long long*)arg[2]);
  else ::new(mem) ::JRAEvent(*(int*)arg[0],
      *(float*)arg[1],
      *(long long*)arg[2]);
}

static void constructor_2730( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::JRAEvent();
  else ::new(mem) ::JRAEvent();
}

static void method_newdel_9( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::JRAEvent >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::JRAEvent >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::JRAEvent >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::JRAEvent >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::JRAEvent >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class JRAEvent -------------------------------
void __JRAEvent_db_datamem(Reflex::Class*);
void __JRAEvent_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __JRAEvent_datamem_bld(&__JRAEvent_db_datamem);
Reflex::GenreflexMemberBuilder __JRAEvent_funcmem_bld(&__JRAEvent_db_funcmem);
void __JRAEvent_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("JRAEvent"), typeid(::JRAEvent), sizeof(::JRAEvent), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "15")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~JRAEvent"), destructor_2726, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3873, type_3875), Reflex::Literal("operator="), operator_2727, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3875), Reflex::Literal("JRAEvent"), constructor_2728, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_62, type_658, type_2815), Reflex::Literal("JRAEvent"), constructor_2729, 0, "i;f;l", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("JRAEvent"), constructor_2730, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__JRAEvent_datamem_bld);
}

//------Delayed data member builder for class JRAEvent -------------------
void __JRAEvent_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_62, Reflex::Literal("nref"), OffsetOf(__shadow__::__JRAEvent, nref), ::Reflex::PUBLIC)
  .AddDataMember(type_658, Reflex::Literal("rho"), OffsetOf(__shadow__::__JRAEvent, rho), ::Reflex::PUBLIC)
  .AddDataMember(type_658, Reflex::Literal("rho50"), OffsetOf(__shadow__::__JRAEvent, rho50), ::Reflex::PUBLIC)
  .AddDataMember(type_658, Reflex::Literal("rho_hlt"), OffsetOf(__shadow__::__JRAEvent, rho_hlt), ::Reflex::PUBLIC)
  .AddDataMember(type_658, Reflex::Literal("pthat"), OffsetOf(__shadow__::__JRAEvent, pthat), ::Reflex::PUBLIC)
  .AddDataMember(type_658, Reflex::Literal("weight"), OffsetOf(__shadow__::__JRAEvent, weight), ::Reflex::PUBLIC)
  .AddDataMember(type_2815, Reflex::Literal("npv"), OffsetOf(__shadow__::__JRAEvent, npv), ::Reflex::PUBLIC)
  .AddDataMember(type_2815, Reflex::Literal("run"), OffsetOf(__shadow__::__JRAEvent, run), ::Reflex::PUBLIC)
  .AddDataMember(type_2815, Reflex::Literal("lumi"), OffsetOf(__shadow__::__JRAEvent, lumi), ::Reflex::PUBLIC)
  .AddDataMember(type_2815, Reflex::Literal("evt"), OffsetOf(__shadow__::__JRAEvent, evt), ::Reflex::PUBLIC)
  .AddDataMember(type_2260, Reflex::Literal("npus"), OffsetOf(__shadow__::__JRAEvent, npus), ::Reflex::PUBLIC)
  .AddDataMember(type_2260, Reflex::Literal("bxns"), OffsetOf(__shadow__::__JRAEvent, bxns), ::Reflex::PUBLIC)
  .AddDataMember(type_2260, Reflex::Literal("ntrks_lowpt"), OffsetOf(__shadow__::__JRAEvent, ntrks_lowpt), ::Reflex::PUBLIC)
  .AddDataMember(type_2260, Reflex::Literal("ntrks_highpt"), OffsetOf(__shadow__::__JRAEvent, ntrks_highpt), ::Reflex::PUBLIC)
  .AddDataMember(type_2260, Reflex::Literal("nrefrank"), OffsetOf(__shadow__::__JRAEvent, nrefrank), ::Reflex::PUBLIC)
  .AddDataMember(type_2260, Reflex::Literal("refpdgid"), OffsetOf(__shadow__::__JRAEvent, refpdgid), ::Reflex::PUBLIC)
  .AddDataMember(type_2260, Reflex::Literal("refpdgid_algorithmicDef"), OffsetOf(__shadow__::__JRAEvent, refpdgid_algorithmicDef), ::Reflex::PUBLIC)
  .AddDataMember(type_2260, Reflex::Literal("refpdgid_physicsDef"), OffsetOf(__shadow__::__JRAEvent, refpdgid_physicsDef), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("tnpus"), OffsetOf(__shadow__::__JRAEvent, tnpus), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("zpositions"), OffsetOf(__shadow__::__JRAEvent, zpositions), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("sumpt_lowpt"), OffsetOf(__shadow__::__JRAEvent, sumpt_lowpt), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("sumpt_highpt"), OffsetOf(__shadow__::__JRAEvent, sumpt_highpt), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("refe"), OffsetOf(__shadow__::__JRAEvent, refe), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("refpt"), OffsetOf(__shadow__::__JRAEvent, refpt), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("refeta"), OffsetOf(__shadow__::__JRAEvent, refeta), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("refphi"), OffsetOf(__shadow__::__JRAEvent, refphi), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("refy"), OffsetOf(__shadow__::__JRAEvent, refy), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("refdrjt"), OffsetOf(__shadow__::__JRAEvent, refdrjt), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("refdphijt"), OffsetOf(__shadow__::__JRAEvent, refdphijt), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("refarea"), OffsetOf(__shadow__::__JRAEvent, refarea), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("jte"), OffsetOf(__shadow__::__JRAEvent, jte), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("jtpt"), OffsetOf(__shadow__::__JRAEvent, jtpt), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("jteta"), OffsetOf(__shadow__::__JRAEvent, jteta), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("jtphi"), OffsetOf(__shadow__::__JRAEvent, jtphi), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("jty"), OffsetOf(__shadow__::__JRAEvent, jty), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("jtjec"), OffsetOf(__shadow__::__JRAEvent, jtjec), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("jtarea"), OffsetOf(__shadow__::__JRAEvent, jtarea), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("jtemf"), OffsetOf(__shadow__::__JRAEvent, jtemf), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("jtchf"), OffsetOf(__shadow__::__JRAEvent, jtchf), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("jtnhf"), OffsetOf(__shadow__::__JRAEvent, jtnhf), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("jtnef"), OffsetOf(__shadow__::__JRAEvent, jtnef), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("jtcef"), OffsetOf(__shadow__::__JRAEvent, jtcef), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("jtmuf"), OffsetOf(__shadow__::__JRAEvent, jtmuf), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("jthfhf"), OffsetOf(__shadow__::__JRAEvent, jthfhf), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("jthfef"), OffsetOf(__shadow__::__JRAEvent, jthfef), ::Reflex::PUBLIC)
  .AddDataMember(type_2259, Reflex::Literal("refdzvtx"), OffsetOf(__shadow__::__JRAEvent, refdzvtx), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class JRAEvent -------------------
void __JRAEvent_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<JRAEvent,std::allocator<JRAEvent> > -------------------------------
static void constructor_3886( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<JRAEvent>();
  else ::new(mem) ::std::vector<JRAEvent>();
}

static void constructor_3887( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<JRAEvent>(*(const ::std::allocator<JRAEvent>*)arg[0]);
  else ::new(mem) ::std::vector<JRAEvent>(*(const ::std::allocator<JRAEvent>*)arg[0]);
}

static void constructor_3888( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<JRAEvent>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<JRAEvent>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<JRAEvent>(*(::std::size_t*)arg[0],
      *(const ::JRAEvent*)arg[1]);
  else ::new(mem) ::std::vector<JRAEvent>(*(::std::size_t*)arg[0],
      *(const ::JRAEvent*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<JRAEvent>(*(::std::size_t*)arg[0],
      *(const ::JRAEvent*)arg[1],
      *(const ::std::allocator<JRAEvent>*)arg[2]);
  else ::new(mem) ::std::vector<JRAEvent>(*(::std::size_t*)arg[0],
      *(const ::JRAEvent*)arg[1],
      *(const ::std::allocator<JRAEvent>*)arg[2]);
  }
}

static void constructor_3889( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<JRAEvent>(*(const ::std::vector<JRAEvent>*)arg[0]);
  else ::new(mem) ::std::vector<JRAEvent>(*(const ::std::vector<JRAEvent>*)arg[0]);
}

static void destructor_3890(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<JRAEvent>*)o)->::std::vector<JRAEvent>::~vector)();
}
static  void operator_3891( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<JRAEvent>*)o)->operator=)(*(const ::std::vector<JRAEvent>*)arg[0]);
  else   (((::std::vector<JRAEvent>*)o)->operator=)(*(const ::std::vector<JRAEvent>*)arg[0]);
}

static  void method_3892( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<JRAEvent>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::JRAEvent*)arg[1]);
}

static  void method_3893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<JRAEvent*,std::vector<JRAEvent> >)((((::std::vector<JRAEvent>*)o)->begin)());
  else   (((::std::vector<JRAEvent>*)o)->begin)();
}

static  void method_3894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const JRAEvent*,std::vector<JRAEvent> >)((((const ::std::vector<JRAEvent>*)o)->begin)());
  else   (((const ::std::vector<JRAEvent>*)o)->begin)();
}

static  void method_3895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<JRAEvent*,std::vector<JRAEvent> >)((((::std::vector<JRAEvent>*)o)->end)());
  else   (((::std::vector<JRAEvent>*)o)->end)();
}

static  void method_3896( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const JRAEvent*,std::vector<JRAEvent> >)((((const ::std::vector<JRAEvent>*)o)->end)());
  else   (((const ::std::vector<JRAEvent>*)o)->end)();
}

static  void method_3901( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<JRAEvent>*)o)->size)());
  else   (((const ::std::vector<JRAEvent>*)o)->size)();
}

static  void method_3902( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<JRAEvent>*)o)->max_size)());
  else   (((const ::std::vector<JRAEvent>*)o)->max_size)();
}

static  void method_3903( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<JRAEvent>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<JRAEvent>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::JRAEvent*)arg[1]);
  }
}

static  void method_3904( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<JRAEvent>*)o)->capacity)());
  else   (((const ::std::vector<JRAEvent>*)o)->capacity)();
}

static  void method_3905( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<JRAEvent>*)o)->empty)());
  else   (((const ::std::vector<JRAEvent>*)o)->empty)();
}

static  void method_3906( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<JRAEvent>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3907( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<JRAEvent>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<JRAEvent>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3908( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<JRAEvent>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<JRAEvent>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3910( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<JRAEvent>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<JRAEvent>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3911( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<JRAEvent>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<JRAEvent>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3912( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<JRAEvent>*)o)->front)();
  else   (((::std::vector<JRAEvent>*)o)->front)();
}

static  void method_3913( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<JRAEvent>*)o)->front)();
  else   (((const ::std::vector<JRAEvent>*)o)->front)();
}

static  void method_3914( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<JRAEvent>*)o)->back)();
  else   (((::std::vector<JRAEvent>*)o)->back)();
}

static  void method_3915( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<JRAEvent>*)o)->back)();
  else   (((const ::std::vector<JRAEvent>*)o)->back)();
}

static  void method_3916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<JRAEvent>*)o)->data)());
  else   (((::std::vector<JRAEvent>*)o)->data)();
}

static  void method_3917( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<JRAEvent>*)o)->data)());
  else   (((const ::std::vector<JRAEvent>*)o)->data)();
}

static  void method_3918( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<JRAEvent>*)o)->push_back)(*(const ::JRAEvent*)arg[0]);
}

static  void method_3919( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<JRAEvent>*)o)->pop_back)();
}

static  void method_3920( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<JRAEvent*,std::vector<JRAEvent> >)((((::std::vector<JRAEvent>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<JRAEvent*,std::vector<JRAEvent> >*)arg[0],
    *(const ::JRAEvent*)arg[1]));
  else   (((::std::vector<JRAEvent>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<JRAEvent*,std::vector<JRAEvent> >*)arg[0],
    *(const ::JRAEvent*)arg[1]);
}

static  void method_3921( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<JRAEvent>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<JRAEvent*,std::vector<JRAEvent> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::JRAEvent*)arg[2]);
}

static  void method_3922( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<JRAEvent*,std::vector<JRAEvent> >)((((::std::vector<JRAEvent>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<JRAEvent*,std::vector<JRAEvent> >*)arg[0]));
  else   (((::std::vector<JRAEvent>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<JRAEvent*,std::vector<JRAEvent> >*)arg[0]);
}

static  void method_3923( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<JRAEvent*,std::vector<JRAEvent> >)((((::std::vector<JRAEvent>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<JRAEvent*,std::vector<JRAEvent> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<JRAEvent*,std::vector<JRAEvent> >*)arg[1]));
  else   (((::std::vector<JRAEvent>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<JRAEvent*,std::vector<JRAEvent> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<JRAEvent*,std::vector<JRAEvent> >*)arg[1]);
}

static  void method_3924( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<JRAEvent>*)o)->swap)(*(::std::vector<JRAEvent>*)arg[0]);
}

static  void method_3925( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<JRAEvent>*)o)->clear)();
}

static void method_newdel_1348( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<JRAEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<JRAEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<JRAEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<JRAEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<JRAEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x2( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<JRAEvent,std::allocator<JRAEvent> >")), ::Reflex::BaseOffset< ::std::vector<JRAEvent>,::std::_Vector_base<JRAEvent,std::allocator<JRAEvent> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<JRAEvent> >::Generate();
  else ::Reflex::Proxy< ::std::vector<JRAEvent> >::Generate();
}

//------Dictionary for class vector<JRAEvent,std::allocator<JRAEvent> > -------------------------------
void __std__vector_JRAEvent__db_datamem(Reflex::Class*);
void __std__vector_JRAEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_JRAEvent__datamem_bld(&__std__vector_JRAEvent__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_JRAEvent__funcmem_bld(&__std__vector_JRAEvent__db_funcmem);
void __std__vector_JRAEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<JRAEvent>"), typeid(::std::vector<JRAEvent>), sizeof(::std::vector<JRAEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1806, ::Reflex::BaseOffset< ::std::vector<JRAEvent>, ::std::_Vector_base<JRAEvent,std::allocator<JRAEvent> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_9, Reflex::Literal("std::vector<JRAEvent>::_Alloc_value_type"))
  .AddTypedef(type_1806, Reflex::Literal("std::vector<JRAEvent>::_Base"))
  .AddTypedef(type_2465, Reflex::Literal("std::vector<JRAEvent>::_Tp_alloc_type"))
  .AddTypedef(type_3866, Reflex::Literal("std::vector<JRAEvent>::_Alloc_traits"))
  .AddTypedef(type_9, Reflex::Literal("std::vector<JRAEvent>::value_type"))
  .AddTypedef(type_3869, Reflex::Literal("std::vector<JRAEvent>::pointer"))
  .AddTypedef(type_3871, Reflex::Literal("std::vector<JRAEvent>::const_pointer"))
  .AddTypedef(type_3873, Reflex::Literal("std::vector<JRAEvent>::reference"))
  .AddTypedef(type_3875, Reflex::Literal("std::vector<JRAEvent>::const_reference"))
  .AddTypedef(type_3877, Reflex::Literal("std::vector<JRAEvent>::iterator"))
  .AddTypedef(type_3879, Reflex::Literal("std::vector<JRAEvent>::const_iterator"))
  .AddTypedef(type_2571, Reflex::Literal("std::vector<JRAEvent>::const_reverse_iterator"))
  .AddTypedef(type_2572, Reflex::Literal("std::vector<JRAEvent>::reverse_iterator"))
  .AddTypedef(type_2451, Reflex::Literal("std::vector<JRAEvent>::size_type"))
  .AddTypedef(type_2348, Reflex::Literal("std::vector<JRAEvent>::difference_type"))
  .AddTypedef(type_2465, Reflex::Literal("std::vector<JRAEvent>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3886, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14581), Reflex::Literal("vector"), constructor_3887, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2451, type_3875, type_14581), Reflex::Literal("vector"), constructor_3888, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14582), Reflex::Literal("vector"), constructor_3889, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3890, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1348, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x2, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_JRAEvent__funcmem_bld);
}

//------Delayed data member builder for class vector<JRAEvent,std::allocator<JRAEvent> > -------------------
void __std__vector_JRAEvent__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<JRAEvent,std::allocator<JRAEvent> > -------------------
void __std__vector_JRAEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14583, type_14582), Reflex::Literal("operator="), operator_3891, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2731, type_2451, type_3875), Reflex::Literal("assign"), method_3892, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3877), Reflex::Literal("begin"), method_3893, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3879), Reflex::Literal("begin"), method_3894, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3877), Reflex::Literal("end"), method_3895, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3879), Reflex::Literal("end"), method_3896, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2451), Reflex::Literal("size"), method_3901, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2451), Reflex::Literal("max_size"), method_3902, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2731, type_2451, type_9), Reflex::Literal("resize"), method_3903, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2451), Reflex::Literal("capacity"), method_3904, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2766), Reflex::Literal("empty"), method_3905, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2731, type_2451), Reflex::Literal("reserve"), method_3906, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3873, type_2451), Reflex::Literal("operator[]"), operator_3907, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3875, type_2451), Reflex::Literal("operator[]"), operator_3908, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3873, type_2451), Reflex::Literal("at"), method_3910, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3875, type_2451), Reflex::Literal("at"), method_3911, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3873), Reflex::Literal("front"), method_3912, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3875), Reflex::Literal("front"), method_3913, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3873), Reflex::Literal("back"), method_3914, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3875), Reflex::Literal("back"), method_3915, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3869), Reflex::Literal("data"), method_3916, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3871), Reflex::Literal("data"), method_3917, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2731, type_3875), Reflex::Literal("push_back"), method_3918, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2731), Reflex::Literal("pop_back"), method_3919, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3877, type_3877, type_3875), Reflex::Literal("insert"), method_3920, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2731, type_3877, type_2451, type_3875), Reflex::Literal("insert"), method_3921, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3877, type_3877), Reflex::Literal("erase"), method_3922, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3877, type_3877, type_3877), Reflex::Literal("erase"), method_3923, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2731, type_14583), Reflex::Literal("swap"), method_3924, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2731), Reflex::Literal("clear"), method_3925, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<std::vector<JRAEvent, std::allocator<JRAEvent> > > -------------------------------
static void constructor_13697( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<JRAEvent> >();
  else ::new(mem) ::edm::Wrapper<std::vector<JRAEvent> >();
}

static void constructor_13698( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<JRAEvent> >(*(::std::auto_ptr<std::vector<JRAEvent> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<JRAEvent> >(*(::std::auto_ptr<std::vector<JRAEvent> >*)arg[0]);
}

static void destructor_13699(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<JRAEvent> >*)o)->::edm::Wrapper<std::vector<JRAEvent> >::~Wrapper)();
}
static  void method_13700( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<JRAEvent> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<JRAEvent> >*)o)->product)();
}

static  void operator_13701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<JRAEvent> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<JRAEvent> >*)o)->operator->)();
}

static  void method_13702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<JRAEvent> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<JRAEvent> >*)o)->productTypeInfo)();
}

static  void method_13703( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<JRAEvent> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<JRAEvent> >*)o)->typeInfo)();
}

static void constructor_13704( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<JRAEvent> >((::std::vector<JRAEvent>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<JRAEvent> >((::std::vector<JRAEvent>*)arg[0]);
}

static  void method_13705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<JRAEvent> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<JRAEvent> >*)o)->getInterface)();
}

static  void method_13706( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<JRAEvent> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13707( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<JRAEvent> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13708( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<JRAEvent> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13709( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<JRAEvent> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<JRAEvent> >*)o)->dynamicTypeInfo)();
}

static  void method_13710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<JRAEvent> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<JRAEvent> >*)o)->isPresent)();
}

static  void method_13711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<JRAEvent> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<JRAEvent> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3358( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<JRAEvent> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<JRAEvent> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<JRAEvent> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<JRAEvent> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<JRAEvent> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<JRAEvent, std::allocator<JRAEvent> > > -------------------------------
void __edm__Wrapper_std__vector_JRAEvent_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_JRAEvent_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_JRAEvent_s__datamem_bld(&__edm__Wrapper_std__vector_JRAEvent_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_JRAEvent_s__funcmem_bld(&__edm__Wrapper_std__vector_JRAEvent_s__db_funcmem);
void __edm__Wrapper_std__vector_JRAEvent_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<JRAEvent> >"), typeid(::edm::Wrapper<std::vector<JRAEvent> >), sizeof(::edm::Wrapper<std::vector<JRAEvent> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1348, Reflex::Literal("edm::Wrapper<std::vector<JRAEvent> >::value_type"))
  .AddTypedef(type_1348, Reflex::Literal("edm::Wrapper<std::vector<JRAEvent> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13697, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2028), Reflex::Literal("Wrapper"), constructor_13698, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13699, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21971), Reflex::Literal("Wrapper"), constructor_13704, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3358, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_JRAEvent_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_JRAEvent_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<JRAEvent, std::allocator<JRAEvent> > > -------------------
void __edm__Wrapper_std__vector_JRAEvent_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2766, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_JRAEvent_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1348, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_JRAEvent_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<JRAEvent, std::allocator<JRAEvent> > > -------------------
void __edm__Wrapper_std__vector_JRAEvent_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21970), Reflex::Literal("product"), method_13700, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21970), Reflex::Literal("operator->"), operator_13701, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3342), Reflex::Literal("productTypeInfo"), method_13702, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3342), Reflex::Literal("typeInfo"), method_13703, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21972), Reflex::Literal("getInterface"), method_13705, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2731, type_13778, type_17840, type_21914), Reflex::Literal("fillView"), method_13706, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2731, type_3342, type_222, type_5051), Reflex::Literal("setPtr"), method_13707, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2731, type_3342, type_17841, type_17840), Reflex::Literal("fillPtrVector"), method_13708, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3342), Reflex::Literal("dynamicTypeInfo"), method_13709, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2766), Reflex::Literal("isPresent"), method_13710, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3342), Reflex::Literal("dynamicTypeInfo_"), method_13711, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<JRAEvent> -------------------------------
static void constructor_13718( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<JRAEvent>();
  else ::new(mem) ::edm::Wrapper<JRAEvent>();
}

static void constructor_13719( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<JRAEvent>(*(::std::auto_ptr<JRAEvent>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<JRAEvent>(*(::std::auto_ptr<JRAEvent>*)arg[0]);
}

static void destructor_13720(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<JRAEvent>*)o)->::edm::Wrapper<JRAEvent>::~Wrapper)();
}
static  void method_13721( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<JRAEvent>*)o)->product)());
  else   (((const ::edm::Wrapper<JRAEvent>*)o)->product)();
}

static  void operator_13722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<JRAEvent>*)o)->operator->)());
  else   (((const ::edm::Wrapper<JRAEvent>*)o)->operator->)();
}

static  void method_13723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<JRAEvent>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<JRAEvent>*)o)->productTypeInfo)();
}

static  void method_13724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<JRAEvent>*)o)->typeInfo)();
  else   (((::edm::Wrapper<JRAEvent>*)o)->typeInfo)();
}

static void constructor_13725( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<JRAEvent>((::JRAEvent*)arg[0]);
  else ::new(mem) ::edm::Wrapper<JRAEvent>((::JRAEvent*)arg[0]);
}

static  void method_13726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<JRAEvent>*)o)->getInterface)());
  else   (((::edm::Wrapper<JRAEvent>*)o)->getInterface)();
}

static  void method_13727( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<JRAEvent>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13728( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<JRAEvent>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13729( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<JRAEvent>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<JRAEvent>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<JRAEvent>*)o)->dynamicTypeInfo)();
}

static  void method_13731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<JRAEvent>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<JRAEvent>*)o)->isPresent)();
}

static  void method_13732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<JRAEvent>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<JRAEvent>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3359( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<JRAEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<JRAEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<JRAEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<JRAEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<JRAEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<JRAEvent> -------------------------------
void __edm__Wrapper_JRAEvent__db_datamem(Reflex::Class*);
void __edm__Wrapper_JRAEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_JRAEvent__datamem_bld(&__edm__Wrapper_JRAEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_JRAEvent__funcmem_bld(&__edm__Wrapper_JRAEvent__db_funcmem);
void __edm__Wrapper_JRAEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<JRAEvent>"), typeid(::edm::Wrapper<JRAEvent>), sizeof(::edm::Wrapper<JRAEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "edm::Wrapper<JRAEvent>")
  .AddTypedef(type_9, Reflex::Literal("edm::Wrapper<JRAEvent>::value_type"))
  .AddTypedef(type_9, Reflex::Literal("edm::Wrapper<JRAEvent>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13718, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2029), Reflex::Literal("Wrapper"), constructor_13719, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13720, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3869), Reflex::Literal("Wrapper"), constructor_13725, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3359, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_JRAEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_JRAEvent__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<JRAEvent> -------------------
void __edm__Wrapper_JRAEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2766, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_JRAEvent_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_9, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_JRAEvent_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<JRAEvent> -------------------
void __edm__Wrapper_JRAEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3871), Reflex::Literal("product"), method_13721, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3871), Reflex::Literal("operator->"), operator_13722, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3342), Reflex::Literal("productTypeInfo"), method_13723, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3342), Reflex::Literal("typeInfo"), method_13724, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21975), Reflex::Literal("getInterface"), method_13726, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2731, type_13778, type_17840, type_21914), Reflex::Literal("fillView"), method_13727, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2731, type_3342, type_222, type_5051), Reflex::Literal("setPtr"), method_13728, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2731, type_3342, type_17841, type_17840), Reflex::Literal("fillPtrVector"), method_13729, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3342), Reflex::Literal("dynamicTypeInfo"), method_13730, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2766), Reflex::Literal("isPresent"), method_13731, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3342), Reflex::Literal("dynamicTypeInfo_"), method_13732, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __JRAEvent_dict(); 
      __std__vector_JRAEvent__dict(); 
      __edm__Wrapper_std__vector_JRAEvent_s__dict(); 
      __edm__Wrapper_JRAEvent__dict(); 
    }
    ~Dictionaries() {
      type_9.Unload(); // class JRAEvent 
      type_1348.Unload(); // class std::vector<JRAEvent> 
      type_3358.Unload(); // class edm::Wrapper<std::vector<JRAEvent> > 
      type_3359.Unload(); // class edm::Wrapper<JRAEvent> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
